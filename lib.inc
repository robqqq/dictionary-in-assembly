section .text 

global exit
global string_length
global print_string
global print_char
global print_newline
global print_uint
global print_int
global string_equals
global read_char
global read_word
global read_string
global parse_uint
global parse_int
global string_copy

; Принимает код возврата и завершает текущий процесс
exit: 
    mov rax, 60 ; Код системного вызова "Выход"
    syscall     ; Системный вызов
    ret 

; Принимает указатель на нуль-терминированную строку, возвращает её длину
string_length:
    xor rax, rax            ; Обнуление аккумулятора, здесь будем хранить подсчитываемую длину
.loop:
    cmp byte [rdi + rax], 0 ; Проверка, яляется ли текущий байт нуль-терминатором
    je .end                 ; Если да, то возврат
    inc rax                 ; Увеличиваем аккумулятор на 1
    jmp .loop
.end:    
    ret

; Принимает дескриптор и указатель на нуль-терминированную строку, выводит строку в указанный дескриптор
print_string:
    push rdi            ; сохраняем дескриптор
    push rsi            ; сохраняем указатель на строку
    mov rdi, rsi
    call string_length  ; Определение длины строки
    pop rsi             ; возвращаем указатель на строку
    pop rdi             ; возвращаем дескриптор
    mov rdx, rax        ; Длина строки в байтах
    mov rax, 1          ; Код системного вызова "Вывод"
    syscall             ; Системный вызов
    ret

; Принимает код символа и выводит его в stdout
print_char:
    push rdi        ; Сохранить выводимый символ на стеке
    mov rax, 1      ; Код системного вызова "Вывод"
    mov rdi, 1      ; Дескриптор stdout
    mov rsi, rsp    ; Указатель на строку (Указатель на стек, т.к. мы записали символ в стек)
    mov rdx, 1      ; Длина строки в байтах (1, т.к. выводим 1 символ)
    syscall         ; Системный вызов
    pop rdi         ; Возвращение стека в исходное состояние
    ret

; Переводит строку (выводит символ с кодом 0xA)
print_newline:
    mov rdi, 0xA        ; Символ переноса строки
    call print_char     ; Вывод символа
    ret

; Выводит беззнаковое 8-байтовое число в десятичном формате 
; Совет: выделите место в стеке и храните там результаты деления
; Не забудьте перевести цифры в их ASCII коды.
print_uint:
    mov r9, 10          ; Основание 10-чной системы счисления
    mov rax, rdi    
    mov rdi, rsp    
    dec rdi         
    push 0              ; Символ окончания строки
    sub rsp, 16         ; Выделения буфера в стеке для строки
.loop:
    xor rdx, rdx        ; Обнуление rdx
    div r9              ; Целочисленное деление на 10
    add rdx, '0'        ; Прибавление к остатку кода символа "0" для получения кода необходимого символа
    dec rdi             ; Уменьшения указателя на текущий записываемый символ
    mov byte[rdi], dl   ; Запись символа в буфер
    test rax, rax       ; Проверка, продолжать ли вычисление 10-чной записи числа
    jnz .loop           ; Если да, то переход на .loop
    call print_string   ; Вывод строки
    add rsp, 24         ; Возврат стека в исходное состояние
    ret

; Выводит знаковое 8-байтовое число в десятичном формате 
print_int:
    cmp rdi, 0      ; Определение знака числа
    jge .positive   ; Если положительное - пропуск инструкций необходимых для вывода отрицательного числа
    push rdi        ; Положить в стек число
    mov rdi, '-'    ; Код символа минус
    call print_char ; Вывод символа минус
    pop rdi         ; Достать из стека число
    neg rdi         ; Получить противоположное число
.positive:
    call print_uint ; Вывод беззнакового целого числа
    ret

; Принимает два указателя на нуль-терминированные строки, возвращает 1 если они равны, 0 иначе
string_equals:
    push rdi
    push rsi
    call string_length          ; Если длины строк не равны,
    pop rdi
    pop rsi
    push rdi
    push rsi
    push rax
    call string_length
    pop rdx
    pop rsi
    pop rdi
    cmp rdx, rax
    jne .false
    xor rcx, rcx
.loop:
    mov dl, byte[rdi + rcx]     ; Побайтовое сравнение строк:
    cmp dl, byte[rsi + rcx]     ; если соотв. байты не равны,
    jne .false                  ; то строки не равны
    inc rcx
    cmp dl, 0                   ; Если не достигнут конец строки,
    jne .loop                   ; то переход к следующей итерации
    mov rax, 1                  ; 1 - строки равны
    ret                         ; Возврат
.false:
    xor rax, rax                ; 0 - строки не равны
    ret                         ; Возврат

; Читает один символ из stdin и возвращает его. Возвращает 0 если достигнут конец потока
read_char:
    xor rax, rax    ; Номер системного вызова "Вывод"
    xor rdi, rdi    ; Дескриптор stdin
    push 0          ; Буфер в стеке
    mov rsi, rsp    ; Указатель на буфер для записи
    mov rdx, 1      ; Длина вводимой строки - 1
    syscall         ; Системный вызов
    pop rax         ; Достаем из стека введенный символ
    ret 

; Принимает: адрес начала буфера, размер буфера
; Читает в буфер слово из stdin, пропуская пробельные символы в начале, .
; Пробельные символы это пробел 0x20, табуляция 0x9 и перевод строки 0xA.
; Останавливается и возвращает 0 если слово слишком большое для буфера
; При успехе возвращает адрес буфера в rax, длину слова в rdx.
; При неудаче возвращает 0 в rax
; Эта функция должна дописывать к слову нуль-терминатор

read_word:
    xor rcx, rcx            ; Обнуление rcx
.loop:
    push rdi                ; Сохраняем данные в стек
    push rsi
    push rcx
    call read_char          ; Читаем символ
    pop rcx                 ; Достаем данные из стека
    pop rsi
    pop rdi
    cmp rax, 0x20           ; Проверяем на пробельный символ
    je .whitespace
    cmp rax, 0x9
    je .whitespace
    cmp rax, 0xA
    je .whitespace
    cmp rax, 0              ; Проверяем на конец ввода
    je .end
    mov [rdi + rcx], rax    ; Сохраняем символ
    inc rcx                 ; Увеличиваем счетчик длины на 1
    cmp rcx, rsi            ; Проверка на переполнение буфера
    jge .err
    jmp .loop
.whitespace:
    cmp rcx, 0              ; Если начало слова, то пропускаем пробельные символы,
    je .loop                ; Иначе завершаем ввод слова
    jmp .end
.err:
    xor rax, rax            ; Обнуление возвращаемых значений
    xor rdx, rdx            ; и возврат при ошибке
    ret
.end:
    xor rax, rax            ; Запись в память нуль-терминатора
    mov [rdi + rcx], rax
    mov rax, rdi            ; Адрес буфера в rax
    mov rdx, rcx            ; Длина строки в rdx
    ret                     ; Возврат


; Принимает: адрес начала буфера, размер буфера
; Читает в буфер строку из stdin, пропуская пробельные символы в начале, .
; Пробельные символы это пробел 0x20, табуляция 0x9 и перевод строки 0xA.
; Перевод строки не в начале завершает ввод строки
; Останавливается и возвращает 0 если строка слишком большая для буфера
; При успехе возвращает адрес буфера в rax, длину строки в rdx.
; При неудаче возвращает 0 в rax
; Эта функция должна дописывать к строке нуль-терминатор
read_string:
    xor rcx, rcx            ; Обнуление rcx
.loop:
    push rdi                ; Сохраняем данные в стек
    push rsi
    push rcx
    call read_char          ; Читаем символ
    pop rcx                 ; Достаем данные из стека
    pop rsi
    pop rdi
    cmp rax, 0x20           ; Проверяем на пробельный символ
    je .whitespace
    cmp rax, 0x9
    je .whitespace
    cmp rax, 0xA
    je .newline
    cmp rax, 0              ; Проверяем на конец ввода
    je .end
.continue:    
    mov [rdi + rcx], rax    ; Сохраняем символ
    inc rcx                 ; Увеличиваем счетчик длины на 1
    cmp rcx, rsi            ; Проверка на переполнение буфера
    jge .err
    jmp .loop
.whitespace:
    cmp rcx, 0              ; Если начало слова, то пропускаем пробельные символы,
    je .loop                ; Иначе продолжаем чтение
    jmp .continue
.newline:
    cmp rcx, 0
    je .loop
    jmp .end
.err:
    xor rax, rax            ; Обнуление возвращаемых значений
    xor rdx, rdx            ; и возврат при ошибке
    ret
.end:
    xor rax, rax            ; Запись в память нуль-терминатора
    mov [rdi + rcx], rax
    mov rax, rdi            ; Адрес буфера в rax
    mov rdx, rcx            ; Длина строки в rdx
    ret                     ; Возврат


; Принимает указатель на строку, пытается
; прочитать из её начала беззнаковое число.
; Возвращает в rax: число, rdx : его длину в символах
; rdx = 0 если число прочитать не удалось
parse_uint:
    mov r8, 10                  ; Основание системы счисления
    xor rcx, rcx                ; Обнуления счетчика длины
    xor rax, rax                ; Обнуление аккумулятора результата
.loop:    
    movzx r9, byte[rdi + rcx]   ; Чтение символа
    cmp r9b, 0                  ; Завершить, если строка закончилась
    je .end                     ; или найден символ, отличный от цифры
    cmp r9b, '0'
    jb .end
    cmp r9b, '9'
    ja .end
    mul r8                      ; Умножить аккумулятор на 10
    sub r9b, '0'                ; Получение цифры из кода ее символа
    add rax, r9                 ; Прибавление цифры к аккумулятору
    inc rcx                     ; Увеличение счетчика длины
    jmp .loop                   ; Повторение цикла
.end:
    mov rdx, rcx                ; Длина строки в rdx
    ret                         ; Возврат




; Принимает указатель на строку, пытается
; прочитать из её начала знаковое число.
; Если есть знак, пробелы между ним и числом не разрешены.
; Возвращает в rax: число, rdx : его длину в символах (включая знак, если он был) 
; rdx = 0 если число прочитать не удалось
parse_int:
    movzx r9, byte[rdi]         ; Чтение первого символа
    cmp r9b, '-'
    je .negative
    push 0                      ; Кладем в стек 0, если число - положительное
    jmp .parse
.negative:
    push 1                      ; Кладем в стек 1, если число - отрицательное
    inc rdi                     ; Увеличиваем указатель на строку на 1, чтобы
                                ; пропустить минус при отрицательном числе
.parse:
    call parse_uint             ; Парсим число, как беззнаковое
    pop r9                      ; Проверяем, был ли минус перед числом
    cmp r9, 0
    je .positive
    neg rax                     ; Если был минус, то берем противоположное число
    inc rdx                     ; беззнаковому и увеличиваем длину на 1 (из-за минуса)
.positive:
    ret                         ; Возврат
    

; Принимает указатель на строку, указатель на буфер и длину буфера
; Копирует строку в буфер
; Возвращает длину строки если она умещается в буфер, иначе 0
string_copy:
    call string_length      ; Определение длины строки
    inc rax                 ; Увеличение на 1, т.к. к строке так же будет дописан 0-терминатор
    cmp rax, rdx            ; Сравнение длины строки и размера буфера
    jg .small_buffer        ; Если длина строки больше размера буфера - переход к возврату нуля
    xor rcx, rcx            ; Обнуление rcx
.loop:
    mov rdx, [rdi + rcx]    ; Запись в rdx текущего элемента строки
    mov [rsi + rcx], rdx    ; Запись в буфер текущего элемента строки
    inc rcx                 ; Инкремент счетчика
    cmp byte[rdi + rcx], 0  ; Проверка, достигнут ли 0-терминатор
    jne .loop               ; Если нет, то повторение итерации цикла
    ret
.small_buffer:
    xor rax, rax            ; Обнуление rax
    ret
